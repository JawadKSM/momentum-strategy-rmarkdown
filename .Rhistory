# Assign equal weights for long and short positions
#momentum_weights_long <- rep(1 / length(momentum_valid_long), length(momentum_valid_long))
#momentum_weights_short <- rep(-1 / length(momentum_valid_short), length(momentum_valid_short))
#momentum_weights <- c(momentum_weights_long, momentum_weights_short)
# Compute new weights based on the strength of the momentum signal
momentum_filtered_scores <- momentum_scores[c(momentum_valid_long, momentum_valid_short), , drop = FALSE]
# Normalize weights for long positions
long_scores <- momentum_filtered_scores[momentum_valid_long, 1]
long_weights <- long_scores / sum(abs(long_scores))  # normalized by absolute value
long_weights <- as.numeric(long_weights)
# Normalize weights for short positions
short_scores <- momentum_filtered_scores[momentum_valid_short, 1]
short_weights <- -short_scores / sum(abs(short_scores))  # negative for shorts
short_weights <- as.numeric(short_weights)
# Combine long and short weights
momentum_weights <- c(long_weights, short_weights)
# Compute portfolio returns based on selected stocks and weights
momentum_portfolio_returns <- Return.portfolio(R = momentum_returns[, c(momentum_valid_long, momentum_valid_short)],weights = momentum_weights)
# Calculate key performance metrics
momentum_mean_return <- mean(momentum_portfolio_returns) * 252
momentum_volatility <- sd(momentum_portfolio_returns) * sqrt(252)
momentum_sharpe_ratio <- momentum_mean_return / momentum_volatility
momentum_max_drawdown <- maxDrawdown(momentum_portfolio_returns)
# Create a dataframe for the results
momentum_results <- data.frame(
Metrics = c("Annualized Return after RSI filter", "Annualized Volatility", "Sharpe Ratio", "Maximum Drawdown"),
Value = c(round(momentum_mean_return * 100, 2),
round(momentum_volatility * 100, 2),
round(momentum_sharpe_ratio, 2),
round(momentum_max_drawdown * 100, 2))
)
names(results)[2] <- "Value (%)"
# Compute daily returns for the selected stocks
momentum_returns <- na.omit(ROC(momentum_price_data, type = "discrete"))
# Assign equal weights for long and short positions
#momentum_weights_long <- rep(1 / length(momentum_valid_long), length(momentum_valid_long))
#momentum_weights_short <- rep(-1 / length(momentum_valid_short), length(momentum_valid_short))
#momentum_weights <- c(momentum_weights_long, momentum_weights_short)
# Compute new weights based on the strength of the momentum signal
momentum_filtered_scores <- momentum_scores[c(momentum_valid_long, momentum_valid_short), , drop = FALSE]
# Normalize weights for long positions
long_scores <- momentum_filtered_scores[momentum_valid_long, 1]
long_weights <- long_scores / sum(abs(long_scores))  # normalized by absolute value
long_weights <- as.numeric(long_weights)
# Normalize weights for short positions
short_scores <- momentum_filtered_scores[momentum_valid_short, 1]
short_weights <- -short_scores / sum(abs(short_scores))  # negative for shorts
short_weights <- as.numeric(short_weights)
# Combine long and short weights
momentum_weights <- c(long_weights, short_weights)
# Compute portfolio returns based on selected stocks and weights
momentum_portfolio_returns <- Return.portfolio(R = momentum_returns[, c(momentum_valid_long, momentum_valid_short)],weights = momentum_weights)
# Calculate key performance metrics
momentum_mean_return <- mean(momentum_portfolio_returns) * 252
momentum_volatility <- sd(momentum_portfolio_returns) * sqrt(252)
momentum_sharpe_ratio <- momentum_mean_return / momentum_volatility
momentum_max_drawdown <- maxDrawdown(momentum_portfolio_returns)
# Create a dataframe for the results
momentum_results <- data.frame(
Metrics = c("Annualized Return after RSI filter", "Annualized Volatility", "Sharpe Ratio", "Maximum Drawdown"),
Value = c(round(momentum_mean_return * 100, 2),
round(momentum_volatility * 100, 2),
round(momentum_sharpe_ratio, 2),
round(momentum_max_drawdown * 100, 2))
)
names(momentum_results)[2] <- "Value (%)"
# Generate a table to display results
kable(momentum_results, format = "html", caption = "Momentum Strategy Performance Metrics") %>%
kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>%
column_spec(1, bold = TRUE)
library(quantmod)
library(PerformanceAnalytics)
library(ggplot2)
library(xts)
library(tidyverse)
library(dplyr)
library(tidyquant)
library(readxl)
library(plotly)
library(reshape2)
library(corrplot)
library(knitr)
library(kableExtra)
momentum_symbols <- c("AAPL", "ABT", "ACN", "ADBE", "AIG", "AMD", "AMGN", "AMT", "AMZN",
"AXP", "BA", "BAC", "BK", "BKNG", "BLK", "BMY", "BRK-B", "C", "CAT", "CL",
"CMCSA", "COF", "COP", "COST", "CRM", "CSCO", "CVS", "CVX", "DE", "DHR", "DIS",
"DUK", "EMR", "F", "FDX", "GD", "GE", "GILD", "GOOG", "GOOGL", "GS", "HD","HON",                       "IBM", "INTC", "INTU", "JNJ", "JPM", "KO", "LIN", "LLY", "LMT", "LOW",
"MCD", "MDLZ", "MDT", "MET", "MMM", "MO", "MRK", "MS", "MSFT", "NEE", "NFLX",
"NKE", "NVDA", "ORCL", "PEP", "PFE", "PG", "QCOM", "RTX", "SBUX", "SCHW",
"SO", "SPG", "T", "TGT", "TMO", "TXN", "UNH", "UNP", "UPS", "USB",
"VZ", "WFC", "WMT", "XOM")
momentum_symbols <- c("AAPL", "ABT", "ACN", "ADBE", "AIG", "AMD", "AMGN", "AMT", "AMZN",
"AXP", "BA", "BAC", "BK", "BKNG", "BLK", "BMY", "BRK-B", "C", "CAT", "CL",
"CMCSA", "COF", "COP", "COST", "CRM", "CSCO", "CVS", "CVX", "DE", "DHR", "DIS",
"DUK", "EMR", "F", "FDX", "GD", "GE", "GILD", "GOOG", "GOOGL", "GS", "HD","HON",                       "IBM", "INTC", "INTU", "JNJ", "JPM", "KO", "LIN", "LLY", "LMT", "LOW",
"MCD", "MDLZ", "MDT", "MET", "MMM", "MO", "MRK", "MS", "MSFT", "NEE", "NFLX",
"NKE", "NVDA", "ORCL", "PEP", "PFE", "PG", "QCOM", "RTX", "SBUX", "SCHW",
"SO", "SPG", "T", "TGT", "TMO", "TXN", "UNH", "UNP", "UPS", "USB",
"VZ", "WFC", "WMT", "XOM")
for (sym in momentum_symbols) {
tryCatch({
getSymbols(sym, src = "yahoo", from = "2005-01-01", to = "2025-01-01")
}, error = function(e) {
cat("Error while downloading for:", sym, "\n")
})
}
# Extract adjusted closing prices
momentum_price_list <- lapply(momentum_symbols, function(sym) {
if (exists(sym)) {
return(Cl(get(sym)))
} else {
return(NULL)
}})
momentum_price_list <- momentum_price_list[!sapply(momentum_price_list, is.null)]
# Merge prices
momentum_price_data <- do.call(merge, momentum_price_list)
colnames(momentum_price_data) <- momentum_symbols[1:ncol(momentum_price_data)]
head(momentum_price_data[, 1:min(5, ncol(momentum_price_data))])
# Compute 6-month returns (momentum)
momentum_scores <- apply(momentum_price_data, 2, function(x) {
if (length(x) >= 126) {
return((x / lag(x, 126)) - 1)
} else {
return(rep(NA, length(x)))
}
})
momentum_scores <- tail(momentum_scores, 1)  # Latest momentum value for each stock
momentum_scores <- na.omit(as.data.frame(t(momentum_scores)))
# Select stocks for Long (Top 30%) and Short (Bottom 30%) positions
momentum_long_stocks <- rownames(momentum_scores)[momentum_scores[, 1] >= quantile(momentum_scores[, 1], 0.7)]
momentum_short_stocks <- rownames(momentum_scores)[momentum_scores[, 1] <= quantile(momentum_scores[, 1], 0.3)]
cat("Stocks to Long:", momentum_long_stocks, "\n")
cat("Stocks to Short:", momentum_short_stocks, "\n")
# Compute the RSI for each stock (I chose 14 days)
momentum_rsi_data <- apply(momentum_price_data, 2, function(x) RSI(x, n = 14))
momentum_rsi_data <- xts(momentum_rsi_data, order.by = index(momentum_price_data)) #Convert to time series
momentum_rsi_data <- na.omit(momentum_rsi_data)  # Remove initial NA values from RSI calculation
# Apply the RSI filter to refine stock selection
momentum_valid_long <- momentum_long_stocks[momentum_rsi_data[nrow(momentum_rsi_data), momentum_long_stocks] < 65]
momentum_valid_short <- momentum_short_stocks[momentum_rsi_data[nrow(momentum_rsi_data), momentum_short_stocks] > 35]
cat("Long Stocks with RSI < 65 :", momentum_valid_long, "\n")
cat("Short Stocks with RSI > 35 :", momentum_valid_short, "\n")
# Compute daily returns for the selected stocks
momentum_returns <- na.omit(ROC(momentum_price_data, type = "discrete"))
# Assign equal weights for long and short positions
momentum_weights_long <- rep(1 / length(momentum_valid_long), length(momentum_valid_long))
momentum_weights_short <- rep(-1 / length(momentum_valid_short), length(momentum_valid_short))
momentum_weights <- c(momentum_weights_long, momentum_weights_short)
# Compute portfolio returns based on selected stocks and weights
momentum_portfolio_returns <- Return.portfolio(R = momentum_returns[, c(momentum_valid_long, momentum_valid_short)],weights = momentum_weights)
# Calculate key performance metrics
momentum_mean_return <- mean(momentum_portfolio_returns) * 252
momentum_volatility <- sd(momentum_portfolio_returns) * sqrt(252)
momentum_sharpe_ratio <- momentum_mean_return / momentum_volatility
momentum_max_drawdown <- maxDrawdown(momentum_portfolio_returns)
# Create a dataframe for the results
momentum_results <- data.frame(
Metrics = c("Annualized Return after RSI filter", "Annualized Volatility", "Sharpe Ratio", "Maximum Drawdown"),
Value = c(round(momentum_mean_return * 100, 2),
round(momentum_volatility * 100, 2),
round(momentum_sharpe_ratio, 2),
round(momentum_max_drawdown * 100, 2))
)
names(results)[2] <- "Value (%)"
# Compute daily returns for the selected stocks
momentum_returns <- na.omit(ROC(momentum_price_data, type = "discrete"))
# Assign equal weights for long and short positions
momentum_weights_long <- rep(1 / length(momentum_valid_long), length(momentum_valid_long))
momentum_weights_short <- rep(-1 / length(momentum_valid_short), length(momentum_valid_short))
momentum_weights <- c(momentum_weights_long, momentum_weights_short)
# Compute portfolio returns based on selected stocks and weights
momentum_portfolio_returns <- Return.portfolio(R = momentum_returns[, c(momentum_valid_long, momentum_valid_short)],weights = momentum_weights)
# Calculate key performance metrics
momentum_mean_return <- mean(momentum_portfolio_returns) * 252
momentum_volatility <- sd(momentum_portfolio_returns) * sqrt(252)
momentum_sharpe_ratio <- momentum_mean_return / momentum_volatility
momentum_max_drawdown <- maxDrawdown(momentum_portfolio_returns)
# Create a dataframe for the results
momentum_results <- data.frame(
Metrics = c("Annualized Return after RSI filter", "Annualized Volatility", "Sharpe Ratio", "Maximum Drawdown"),
Value = c(round(momentum_mean_return * 100, 2),
round(momentum_volatility * 100, 2),
round(momentum_sharpe_ratio, 2),
round(momentum_max_drawdown * 100, 2))
)
names(momentum_results)[2] <- "Value (%)"
# Generate a table to display results
kable(momentum_results, format = "html", caption = "Momentum Strategy Performance Metrics") %>%
kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>%
column_spec(1, bold = TRUE)
# Compute key performance metrics for the Momentum strategy
momentum_cumulative_returns <- cumprod(1 + momentum_portfolio_returns) - 1
momentum_daily_returns <- momentum_portfolio_returns
momentum_drawdown <- Drawdowns(momentum_portfolio_returns)
# Cumulative Performance Graph
momentum_cumulative_returns_df <- data.frame(
Date = index(momentum_cumulative_returns),
Cumulative_Return = as.numeric(coredata(momentum_cumulative_returns)) * 100)
ggplot(momentum_cumulative_returns_df, aes(x = Date, y = Cumulative_Return)) +
geom_line(color = "blue", linewidth = 0.7) +
labs(title = "Momentum Strategy: Cumulative Performance",
x = "Date", y = "Cumulative Return (%)") +
theme_minimal()
# Daily Returns Bar Chart
momentum_daily_returns_df <- data.frame(Date = index(momentum_daily_returns),
DailyReturn = coredata(momentum_daily_returns))
ggplot(momentum_daily_returns_df, aes(x = Date, y = momentum_daily_returns, fill = momentum_daily_returns > 0)) +
geom_bar(stat = "identity", show.legend = FALSE) +
scale_fill_manual(values = c("red", "green")) +
labs(title = "Momentum Strategy: Daily Returns",
x = "Date", y = "Daily Return (%)") +
theme_minimal()
# Daily Returns Bar Chart
momentum_daily_returns_df <- data.frame(Date = index(momentum_daily_returns),
DailyReturn = coredata(momentum_daily_returns))
ggplot(momentum_daily_returns_df, aes(x = Date, y = momentum_daily_returns, fill = momentum_daily_returns > 0)) +
geom_bar(stat = "identity", show.legend = FALSE) +
scale_fill_manual(values = c("red", "green")) +
labs(title = "Momentum Strategy: Daily Returns",
x = "Date", y = "Daily Return (%)") +
theme_minimal()
momentum_symbols <- c("AAPL", "ABT", "ACN", "ADBE", "AIG", "AMD", "AMGN", "AMT", "AMZN",
"AXP", "BA", "BAC", "BK", "BKNG", "BLK", "BMY", "BRK-B", "C", "CAT", "CL",
"CMCSA", "COF", "COP", "COST", "CRM", "CSCO", "CVS", "CVX", "DE", "DHR", "DIS",
"DUK", "EMR", "F", "FDX", "GD", "GE", "GILD", "GOOG", "GOOGL", "GS", "HD","HON",                       "IBM", "INTC", "INTU", "JNJ", "JPM", "KO", "LIN", "LLY", "LMT", "LOW",
"MCD", "MDLZ", "MDT", "MET", "MMM", "MO", "MRK", "MS", "MSFT", "NEE", "NFLX",
"NKE", "NVDA", "ORCL", "PEP", "PFE", "PG", "QCOM", "RTX", "SBUX", "SCHW",
"SO", "SPG", "T", "TGT", "TMO", "TXN", "UNH", "UNP", "UPS", "USB",
"VZ", "WFC", "WMT", "XOM")
for (sym in momentum_symbols) {
tryCatch({
getSymbols(sym, src = "yahoo", from = "2005-01-01", to = "2025-01-01")
}, error = function(e) {
cat("Error while downloading for:", sym, "\n")
})
}
# Extract adjusted closing prices
momentum_price_list <- lapply(momentum_symbols, function(sym) {
if (exists(sym)) {
return(Cl(get(sym)))
} else {
return(NULL)
}})
momentum_price_list <- momentum_price_list[!sapply(momentum_price_list, is.null)]
# Merge prices
momentum_price_data <- do.call(merge, momentum_price_list)
colnames(momentum_price_data) <- momentum_symbols[1:ncol(momentum_price_data)]
head(momentum_price_data[, 1:min(5, ncol(momentum_price_data))])
# Compute 6-month returns (momentum)
momentum_scores <- apply(momentum_price_data, 2, function(x) {
if (length(x) >= 126) {
return((x / lag(x, 126)) - 1)
} else {
return(rep(NA, length(x)))
}
})
momentum_scores <- tail(momentum_scores, 1)  # Latest momentum value for each stock
momentum_scores <- na.omit(as.data.frame(t(momentum_scores)))
# Select stocks for Long (Top 30%) and Short (Bottom 30%) positions
momentum_long_stocks <- rownames(momentum_scores)[momentum_scores[, 1] >= quantile(momentum_scores[, 1], 0.7)]
momentum_short_stocks <- rownames(momentum_scores)[momentum_scores[, 1] <= quantile(momentum_scores[, 1], 0.3)]
cat("Stocks to Long:", momentum_long_stocks, "\n")
cat("Stocks to Short:", momentum_short_stocks, "\n")
# Compute the RSI for each stock (I chose 14 days)
momentum_rsi_data <- apply(momentum_price_data, 2, function(x) RSI(x, n = 14))
momentum_rsi_data <- xts(momentum_rsi_data, order.by = index(momentum_price_data)) #Convert to time series
momentum_rsi_data <- na.omit(momentum_rsi_data)  # Remove initial NA values from RSI calculation
# Apply the RSI filter to refine stock selection
momentum_valid_long <- momentum_long_stocks[momentum_rsi_data[nrow(momentum_rsi_data), momentum_long_stocks] < 65]
momentum_valid_short <- momentum_short_stocks[momentum_rsi_data[nrow(momentum_rsi_data), momentum_short_stocks] > 35]
cat("Long Stocks with RSI < 65 :", momentum_valid_long, "\n")
cat("Short Stocks with RSI > 35 :", momentum_valid_short, "\n")
# Compute daily returns for the selected stocks
momentum_returns <- na.omit(ROC(momentum_price_data, type = "discrete"))
# Assign equal weights for long and short positions
#momentum_weights_long <- rep(1 / length(momentum_valid_long), length(momentum_valid_long))
#momentum_weights_short <- rep(-1 / length(momentum_valid_short), length(momentum_valid_short))
#momentum_weights <- c(momentum_weights_long, momentum_weights_short)
# Compute new weights based on the strength of the momentum signal
momentum_filtered_scores <- momentum_scores[c(momentum_valid_long, momentum_valid_short), , drop = FALSE]
# Normalize weights for long positions
long_scores <- momentum_filtered_scores[momentum_valid_long, 1]
long_weights <- long_scores / sum(abs(long_scores))  # normalized by absolute value
long_weights <- as.numeric(long_weights)
# Normalize weights for short positions
short_scores <- momentum_filtered_scores[momentum_valid_short, 1]
short_weights <- -short_scores / sum(abs(short_scores))  # negative for shorts
short_weights <- as.numeric(short_weights)
# Combine long and short weights
momentum_weights <- c(long_weights, short_weights)
# Compute portfolio returns based on selected stocks and weights
momentum_portfolio_returns <- Return.portfolio(R = momentum_returns[, c(momentum_valid_long, momentum_valid_short)],weights = momentum_weights)
# Calculate key performance metrics
momentum_mean_return <- mean(momentum_portfolio_returns) * 252
momentum_volatility <- sd(momentum_portfolio_returns) * sqrt(252)
momentum_sharpe_ratio <- momentum_mean_return / momentum_volatility
momentum_max_drawdown <- maxDrawdown(momentum_portfolio_returns)
# Create a dataframe for the results
momentum_results <- data.frame(
Metrics = c("Annualized Return after RSI filter", "Annualized Volatility", "Sharpe Ratio", "Maximum Drawdown"),
Value = c(round(momentum_mean_return * 100, 2),
round(momentum_volatility * 100, 2),
round(momentum_sharpe_ratio, 2),
round(momentum_max_drawdown * 100, 2))
)
names(momentum_results)[2] <- "Value (%)"
# Generate a table to display results
kable(momentum_results, format = "html", caption = "Momentum Strategy Performance Metrics") %>%
kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>%
column_spec(1, bold = TRUE)
# Compute key performance metrics for the Momentum strategy
momentum_cumulative_returns <- cumprod(1 + momentum_portfolio_returns) - 1
momentum_daily_returns <- momentum_portfolio_returns
momentum_drawdown <- Drawdowns(momentum_portfolio_returns)
# Cumulative Performance Graph
momentum_cumulative_returns_df <- data.frame(
Date = index(momentum_cumulative_returns),
Cumulative_Return = as.numeric(coredata(momentum_cumulative_returns)) * 100)
ggplot(momentum_cumulative_returns_df, aes(x = Date, y = Cumulative_Return)) +
geom_line(color = "blue", linewidth = 0.7) +
labs(title = "Momentum Strategy: Cumulative Performance",
x = "Date", y = "Cumulative Return (%)") +
theme_minimal()
# Daily Returns Bar Chart
momentum_daily_returns_df <- data.frame(Date = index(momentum_daily_returns),
DailyReturn = coredata(momentum_daily_returns))
ggplot(momentum_daily_returns_df, aes(x = Date, y = momentum_daily_returns, fill = momentum_daily_returns > 0)) +
geom_bar(stat = "identity", show.legend = FALSE) +
scale_fill_manual(values = c("red", "green")) +
labs(title = "Momentum Strategy: Daily Returns",
x = "Date", y = "Daily Return (%)") +
theme_minimal()
# 3 Drawdown Graph
momentum_drawdown_df <- data.frame(Date = index(momentum_drawdown), Drawdown = coredata(momentum_drawdown))
ggplot(momentum_drawdown_df, aes(x = Date, y = momentum_drawdown)) +
geom_line(color = "red", linewidth = 0.7) +
labs(title = "Momentum Strategy: Drawdown",
x = "Date", y = "Drawdown (%)") +
theme_minimal()
# 4 Histogram of Daily Returns
ggplot(data.frame(Returns = coredata(na.omit(momentum_daily_returns))), aes(x = momentum_daily_returns)) +
geom_histogram(bins = 50, fill = "darkgreen", color = "black", alpha = 0.8) +
geom_vline(xintercept = mean(momentum_daily_returns, na.rm = TRUE),
color = "red", linetype = "dashed", linewidth = 1) +
labs(title = "Momentum Strategy: Return Distribution",
x = "Daily Return", y = "Frequency") +
theme_minimal()
library(quantmod)
library(PerformanceAnalytics)
library(ggplot2)
library(xts)
library(tidyverse)
library(dplyr)
library(tidyquant)
library(readxl)
library(plotly)
library(reshape2)
library(corrplot)
library(knitr)
library(kableExtra)
# List of the 88 tickers from the SP100 index
symbols <- c("AAPL", "ABT", "ACN", "ADBE", "AIG", "AMD", "AMGN", "AMT", "AMZN",
"AXP", "BA", "BAC", "BK", "BKNG", "BLK", "BMY", "BRK-B", "C", "CAT", "CL",
"CMCSA", "COF", "COP", "COST", "CRM", "CSCO", "CVS", "CVX", "DE", "DHR", "DIS",
"DUK", "EMR", "F", "FDX", "GD", "GE", "GILD", "GOOG", "GOOGL", "GS", "HD", "HON",
"IBM", "INTC", "INTU", "JNJ", "JPM", "KO", "LIN", "LLY", "LMT", "LOW",
"MCD", "MDLZ", "MDT", "MET", "MMM", "MO", "MRK", "MS", "MSFT", "NEE", "NFLX",
"NKE", "NVDA", "ORCL", "PEP", "PFE", "PG", "QCOM", "RTX", "SBUX", "SCHW",
"SO", "SPG", "T", "TGT", "TMO", "TXN", "UNH", "UNP", "UPS", "USB",
"VZ", "WFC", "WMT", "XOM")
# Download stock data from Yahoo Finance
for (sym in symbols) {
tryCatch({
getSymbols(sym, src = "yahoo", from = "2005-01-01", to = "2025-01-01")
}, error = function(e) {
cat("Error while downloading for:", sym, "\n")
})
}
# Extract adjusted closing prices for each stock
price_list <- lapply(symbols, function(sym) {
if (exists(sym)) {
return(Cl(get(sym)))
} else {
return(NULL)
}
})
names(price_list) <- symbols #Assign stock tickers as column names
# Remove null elements (stocks that were not downloaded)
price_list <- price_list[!sapply(price_list, is.null)]
# Merge prices into a single dataframe
price_data <- do.call(merge, price_list)
colnames(price_data) <- names(price_list)
# Display the number of successfully imported stocks
cat("Number of stocks imported:", ncol(price_data), "\n")
# A Preview the first 5 columns of the dataset to check
head(price_data[, 1:min(5, ncol(price_data))])
# Load the Excel file
current_dir <- getwd() # Get the current working directory
file_path <- file.path(current_dir, "Market_Cap.xlsx") # Build the relative path to my Excel file
market_data <- read_excel(file_path) # Read the file
# Convert market cap to trillions (USD)
market_data <- market_data %>%
mutate(marketcap = as.numeric(marketcap) / 1e12)  # Convert to trillions
# Horizontal bar plot
ggplot(market_data, aes(x = reorder(Name, marketcap), y = marketcap, fill = Name)) +
geom_bar(stat = "identity", show.legend = FALSE) +
coord_flip() +
labs(title = "Market Capitalization of Top 10 Companies",
x = "Company",
y = "Market Capitalization (Trillions USD)") +
theme_minimal() +
scale_fill_manual(values = c("#1f77b4", "#ff7f0e", "#2ca02c", "#d62728",
"#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
"#bcbd22", "#17becf"))
# Ensure 'weight' is correctly formatted as a numeric percentage
market_data <- market_data %>%
mutate(weight = as.numeric(gsub("%", "", weight)))
# Create the pie chart
ggplot(market_data, aes(x = "", y = weight, fill = Name)) +
geom_bar(stat = "identity", width = 1) +
coord_polar(theta = "y") +
geom_text(aes(label = paste0(round(weight * 100, 2), "%")),
position = position_stack(vjust = 0.2), size = 2, color = "white",
fontface="bold") +  # Add labels
scale_fill_brewer(palette = "Paired") +
labs(title = "Weight Distribution of Top 10 Companies in the Portfolio") +
theme_void() +  # Remove background grid
theme(legend.title = element_blank(),
plot.title = element_text(hjust = 0.2, face = "bold"))
# Cumpute the daily returns
returns <- na.omit(ROC(price_data, type = "discrete"))
# Compute correlation matrix
cor_matrix <- cor(returns, use = "pairwise.complete.obs")
# Convert matrix to long format for ggplot
melted_cor <- melt(cor_matrix)
# Plot heatmap with improved readability
ggplot(melted_cor, aes(x = Var1, y = Var2, fill = value)) +
geom_tile(color = "white") +
scale_fill_gradient2(low = "red", high = "green", mid = "white",
midpoint = 0, limit = c(-1,1), space = "Lab",
name="Correlation") +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 5),
axis.text.y = element_text(size = 4),
legend.title = element_text(size = 10),
legend.text = element_text(size = 8)
) +
labs(title = "Correlation Heatmap of the 88 Stocks",
x = "Stock", y = "Stock")
# Compute equal weights for each stock in the portfolio
n <- ncol(returns)
weights <- rep(1/n, n)
# Compute the portfolio returns
portfolio_returns <- Return.portfolio(R = returns, weights = weights)
# Compute key performance metrics
mean_return <- mean(portfolio_returns) * 252  # Annualized mean return
volatility <- sd(portfolio_returns) * sqrt(252)  # Annualized volatility
sharpe_ratio <- mean_return / volatility  # Sharpe ratio
# Create a dataframe to display the performance metrics
results <- data.frame(
Metrics = c("Annualized Mean Return", "Annualized Volatility", "Sharpe Ratio"),
Value = c(round(mean_return * 100, 2), round(volatility * 100, 2), round(sharpe_ratio, 2))
)
names(results)[2] <- "Value (%)"
kable(results, format = "html", caption = "Performance Metrics") %>%
kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>%
column_spec(1, bold = TRUE)
# Computations of some metrics for the graphs
cumulative_returns <- cumprod(1 + portfolio_returns) - 1
daily_returns <- portfolio_returns
drawdown <- Drawdowns(portfolio_returns)
# Cumulative portfolio performance graph
cumulative_returns_df <- data.frame(Date = index(cumulative_returns),
Cumulative_Return = as.numeric(coredata(cumulative_returns)) * 100)
ggplot(cumulative_returns_df, aes(x = Date, y = Cumulative_Return)) +
geom_line(color = "blue", linewidth = 0.7) +
labs(title = "Cumulative Portfolio Performance",
x = "Date", y = "Cumulative return (%)") +
theme_minimal()
# Create a DataFrame for cumulative returns comparison
comparison_cumulative_returns_df <- data.frame(Date = index(momentum_cumulative_returns),
Benchmark_CumReturn = as.numeric(coredata(cumulative_returns)) * 100,
Momentum_CumReturn = as.numeric(coredata(momentum_cumulative_returns)) * 100)
# Create a DataFrame for drawdown comparison
comparison_drawdown_df <- data.frame(Date = index(momentum_drawdown),
Benchmark_Drawdown = as.numeric(coredata(drawdown)) * 100,
Momentum_Drawdown = as.numeric(coredata(momentum_drawdown)) * 100)
# Benchmark vs. Momentum Strategy cumulative performance
ggplot(comparison_cumulative_returns_df, aes(x = Date)) +
geom_line(aes(y = Benchmark_CumReturn, color = "Benchmark"), linewidth = 0.6) +
geom_line(aes(y = Momentum_CumReturn, color = "Momentum Strategy"), linewidth = 0.6) +
scale_color_manual(values = c("Benchmark" = "blue", "Momentum Strategy" = "red")) +
labs(title = "Cumulative Performance: Benchmark vs. Momentum Strategy",
x = "Date", y = "Cumulative Return (%)", color = "Portfolio") +
theme_minimal()
# Crisis periods
crisis_dates <- as.Date(c("2008-09-15", "2021-01-01"))
# Benchmark vs. Momentum Strategy drawdown comparison
ggplot(comparison_drawdown_df, aes(x = Date)) +
geom_line(aes(y = Benchmark_Drawdown, color = "Benchmark"), linewidth = 0.5) +
geom_line(aes(y = Momentum_Drawdown, color = "Momentum Strategy"), linewidth = 0.5) +
geom_vline(xintercept = as.numeric(crisis_dates[1]), linetype = "dashed", color = "black", linewidth = 1.2) +
geom_vline(xintercept = as.numeric(crisis_dates[2]), linetype = "dashed", color = "black", linewidth = 1.2) +
annotate("text", x = crisis_dates[1], y = min(comparison_drawdown_df$Benchmark, na.rm = TRUE),
label = "2008 Crisis", angle = 90, vjust = -0.5, hjust = 1.2, size = 3, color = "black") +
annotate("text", x = crisis_dates[2], y = min(comparison_drawdown_df$Benchmark, na.rm = TRUE),
label = "COVID-19", angle = 90, vjust = -0.5, hjust = 1.2, size = 3, color = "black") +
scale_color_manual(values = c("Benchmark" = "blue", "Momentum Strategy" = "red")) +
labs(title = "Drawdown Comparison: Benchmark vs. Momentum Strategy",
x = "Date", y = "Drawdown (%)", color = "Portfolio") +
theme_minimal()
